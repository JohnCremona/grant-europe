\addtocounter{wpno}{1}
\begin{Workpackage}{\thewpno}
  \wplabel{wp:component-architecture}
  \WPTitle{\wpname{\thewpno}}
  \WPStart{Month 1}
  \WPParticipant{PS}{24}
  \WPParticipant{UV}{1}
  \WPParticipant{SA}{1}

  \begin{WPObjectives}
    The objective of this work package is to develop and demonstrate a
    set of API's enabling components such as database interfaces,
    computational modules, separate systems such as GAP or Sage to be
    flexibly combined and run smoothly across a wide range of
    environments (cloud, local, server, ...).
  \end{WPObjectives}

  \begin{WPDescription}
    % This work package includes work on:
    % \begin{itemize}
    % \item Portability:
    %   \begin{itemize}
    %   \item Sharing experience and best practices.
    %   \item Port to Windows (GAP, Sage, Singular).
    %   \item Shared multiplatform test infrastructure.
    %   \end{itemize}
    % \end{itemize}
  \end{WPDescription}


  \begin{task}{Portability}
    In order to achieve maximum availability and accessibility,
    mathematical software must be developed and tested for a wide range
    of computer architectures and operating systems.  However most of
    open source development happens in POSIX environments (usually
    Linux or OSX), and almost exclusively on x86 platforms.  The vast
    majority of the developers of mathematical software does not have
    the expertise, nor the access to appropriate hardware and software, to insure
    appropriate testing and porting of components.  The best
    incarnation of this issue is the involved installation procedure
    for Sage on Windows, a major adoption barrier and common source of
    complaints by end-user.

    In this task we will address the common needs of the community in
    terms of portability layers, building and testing infrastructure.

    \begin{itemize}
    \item Best practices adopted by the larger open source community
      will be investigated and leveraged, and existing expertise will
      be shared between the component developers.
    \item Windows being largely dominant in the desktop/laptop market,
      a specific focus will be placed on the port of \Sage, and
      therefore all the components included in its distribution (in
      particular \Pari, \GAP, \Singular, \Linbox) to this platform
      (D~\ref{del:portability_cygwin32}, D~\ref{del:portability_cygwin64}).
    \item The deployment of a common infrastructure for multi-platform
      continuous integration (testing, building and distribution) will
      be addressed.
    \end{itemize}

      % Jean-Pierre:
      % Should we mention port to non-x86_64 archs and non-Linuces?
      % 
      % For CPUs:
      % - I guess at least ARM and ppc64 (IBM POWER*) really make sense.
      % - Sparc is less convincing though the latest sparc CPUs
      % are muche more interesting for math computation as the
      % previous ones, e.g. the GMP folk specifically added assembly
      % for them in their latest release.
      % - Itanium is dead, but it can help discovering bugs as any non
      % standard archs.
      % - Supporting any of these would mean buying (potentially very
      % expensive) hardware.
      % 
      % For OSes?
      % - Should we mention OS X which is a pain at each new release?
      % - A BSD variant would be interesting, let's say FreeBSD which
      % is basically (almost) already supported
      % - Solaris? and/or OpenIndiana? Interesting if we mention sparc...
      % - Windows is already included below, my opinion is:
      % * provide live USB, VMs and Cygwin32 first as these three are
      % basically already working solutions
      % * go Cygwin64 as it is still POSIX
      % * explorate a MinGW solution, at least GAP and PARI should be
      % problematic
      % * try to use MSVC
  \end{task}

  \begin{task}{Interfaces between systems}
    In this task we will investigate patterns to share data,
    ontologies, and semantics across computational systems, possibly
    connected remotely.  We will leverage the well established
    semantics used in mathematics (categories, type systems, \dots) to
    give powerful abstractions on computational objects.
    
    Through well defined APIs, we will enable discovery of subsystems,
    functionality, documentation and computational resources. The user
    interfaces shall be enabled to automatically choose the best
    available algorithms and resources to perform a required
    computation, as well as clearly and intuitively present the
    available choices to the expert user.

    As a first concrete test bed, we will consider the \Sage interface
    to \GAP, or more precisely \libGAP
    (Deliverable~\ref{del:semantic_interface_sage_gap}). Like most
    \Sage interfaces, this uses the now classical \emph{handle} design
    pattern, whereby one can manipulate from \Sage an object created
    and stored in \GAP, through a \emph{handle} (a.k.a. \emph{remote
      objects}). By introspection, one can discover available \GAP
    functions on this object and access the related \GAP
    documentation. In a few cases, for example when the object is a
    group, one can further wrap the handle with an adapter that makes
    it behave like a native \Sage group.

    By mapping \GAP's categories to \Sage's categories (as a rough
    approximation, both can be thought of as hierarchies of abstract
    classes), we will:
    \begin{itemize}
    \item Implement a modular infrastructure for adapters, based on
      the category hierarchy, in order to let the implementation of
      adapters scale to a large variety of objects.
    \item Refactor the existing adapters, using this infrastructure to
      generalize their features. This step by itself will provide
      adapters for larger categories like semigroups or monoids.
    \item Merge the adapters into the handles, so that a handle to a
      \GAP group will \emph{automatically} behave like a native \Sage
      group.
      % This will remove much back-conversion burden from the
      % delagating methods
    \end{itemize}
    A specific challenge will be performance; indeed low level method
    adapters, e.g. for arithmetic, need to be compiled when most of
    the interface infrastructure is dynamic by nature.

    % When different algorithms are available, some of them coded in
    % \Sage, some of them in \GAP, the interface shall offer an easily
    % navigable interface for the expert user to choose among them.

    \TODO{Other deliverables: generalization to other interfaces,
      factorization of the adapter code through standardized API's,
      semantic-enabled remote objects in SCSCP, reports, ...}
  \end{task}

  \begin{task}{Modularization and packaging}
    In this task we will investigate best practices for composing,
    sharing and interfacing computational components and data for
    connected mathematical systems.

    We will start with a comparative study of the practices adopted in
    various open source projects, both inside and outside of this
    project. This will include reviewing non-mathematical systems,
    e.g.: operating systems, platforms, web frameworks, cloud and HPC
    infrastructures.

    We will address the current shortcomings to promote a new
    generation of mathematical software that is capable of scaling to
    large code bases, large datasets, and massively distributed
    infrastructures. This task also needs to consider the results of
    work package~\ref{wp:social-aspects} on social issues regarding
    distributed development, community management, acknowledging
    contributions, etc.

    As an example, Sage has a long history of integrating and
    distributing large mathematical libraries/software as a whole,
    with relatively few attention given to defining and exposing
    interfaces. Component re-usability is not a main focus for the
    Sage community, at the same time the non-standard and relatively
    underused package system discourages writing and maintaining
    autonomous libraries. These factors have contributed to make the
    Sage distribution what is usually described as a ``monolith''
    (Sage library code alone, not counting included libraries, makes
    up for 1.5M lines of code and documentation), hard to distribute,
    to maintain, to port, and to develop with.

    On the opposite side, GAP has been distributing
    community-developed ``GAP packages'' for a long time, but faces
    now fragmentation issues, at the code and at the community
    level. The rudimentary package system adds more technical
    difficulties to GAP's development model.

    Both models reach the limits of their scalability, and a synthesis
    is very much needed.
  \end{task}
  
  \begin{task}{Deployment and distribution}
    \TODO{NT: what did you have in mind?}
  \end{task}

  \begin{task}{Component architecture for High Performance Computing and Parallelism}
    As in all other areas of science, properly supporting massively
    parallel architecture is a major challenge. Many of the
    computational components have already gone a long way in this
    direction, and further work will happen there within
    WorkPackage~\ref{wp:hpc}.

    In this task we will investigate and implement
    parallelism-friendly ways of combining components together, so
    that calling components can benefit from the parallelism features
    of called components, with self-adaptation to the environment and
    cooperative sharing of resources.
    \TODO{details+deliverables}
  \end{task}

  \begin{task}{Improving the development workflow, in Sage and elsewhere.}
    \TODO{}
  \end{task}

  \begin{WPDeliverables}
    \WPDeliverable{12}{del:portability_cygwin32}{one-click install Sage distribution for Windows with Cygwin 32bits}%
      % JPF: this should take a few months of work
      % This 32bits version would work right away on Windows 64 bits with
      % Cygwin 32 bits; more work would be required for a version working on
      % a 64 bits of Cygwin.
      % JPF: I agree.

    \WPDeliverable{24}{del:portability_cygwin64}{one-click install Sage distribution for Windows with Cygwin 64bits}%

      % Participants involved: Paris Sud, Kaiserslautern, Saint Andrews, Bordeaux
      % Comments on this by Bill Hart
      % The big problems you will have on Windows 64 on Cygwin include:
      % 
      % * anything with assembly language -- the ABI is different on Windows, so
      % it'll need rewriting, or you can incur a performance penalty by using
      % generic C fallback code
      % * the memory allocator on Windows is not so great
      % * bugs exposed due to being on a different platform, e.g. segfaults due to
      % off-by-one errors that were masked by the granularity of malloc on Linux
      % * build issues, due to identifying Cygwin and using the correct header
      % files, which are often different on Cygwin than linux
      % * issues with PATH vs LD_LIBRARY_PATH
      % * Windows has a case insensitive file system
      % * EOL issues
      % * Windows is not able to rapidly create and delete files, which some
      % libraries (esp. test code) calls for
      % * memory limitations (many people using Windows are using laptops with
      % limited memory, only a portion of which is realistically available to
      % Cygwin)
      % * autotools versions that don't support Windows (usually autotools has a
      % release that is used in all the distributions, which doesn't work correctly
      % on Windows, and this is followed up by a version which has all the Windows
      % patches)
      % * building takes forever on Windows. Mingw2 has now gotten parallel build
      % working on Windows and the speed is within a factor of 5 of Linux. But I'm
      % not sure the improvements have propagated to Cygwin yet.
      % * Cygwin 64 is new, contains quite a few bugs still, and things keep
      % changing with every version as they try to get things right.
      % * Although projects will likely accept patches for Windows, they are less
      % likely to maintain support themselves. I would like to think Singular would
      % be an exception to this. And obviously flint and MPIR work on Windows (even
      % with MSVC as of the next version of flint -- or now if you use our bleeding
      % edge repo version).
      % 
      % Comments by Jean-Pierre on some of the above and mor:
      % * first things first: I already completely built Sage on Cygwin64, though it
      % was surely not completely functional.
      % * assembly: that's right, note that as far as Sage and it's dependencies are
      % concerned, only a few of them actually use assembler, and yes all of them
      % provide fallback generic C code IIRC
      % * PATH vs LD_...: basically the same problem as for Cygwin32, so it's already
      % been taken care of for the Cygwin32 port
      % case issue: not a problem IIRC
      % * EOL issues: I don't thing so, Cygwin is POSIX like
      % * autotools issues: most of Sage dependencies are now updated, I used to track
      % the few problematic ones in 2013
      % * time to build: not so long, sure longer than on a POWER7 machine, but I do
      % it on a usual x86_64 laptop running Debian within a Windows VM in a few hours!
      % what we actually really need is patch/build bots to test on Cygwin 32/64!
      % * upstream cooperation: I agree Windows is often a low priority issue, but
      % most teams have welcomed my Cygwin patches

    \WPDeliverable{12}{del:semantic_interface_sage_gap}{Semantic-aware
      Sage interface to GAP.}

    \TODO{Make all those deliverables one-liners, and move the
      material to the task descriptions}
    \begin{itemize}


      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
      % Deliverables: portability and distribution

      % \WPDeliverable{del:ipython_kernels_basic}{12}{Basic Jupyter
      % interface for GAP, Pari, Sage, Singular}

    \item \ref{del:distribution} Make sure that Sage and therefore all the
      components it depends on (including GAP, Linbox, Pari, Singular,
      ...)  have standard packages in the main Linux distributions:
      Debian/Ubuntu, Redhat, Gentoo, ...

      \TODO{Get feedback from our experts, and make this precise; what can
        we actually promise to achieve? how much work is this? Do we have
        personnel for this?  There is strong expertise in Logilab with a
        Debian developer working there; he could advise someone on
        this. Logilab is interested in this because it's meeting similar
        issues with some of its clients software like Salomé.}

    \item \ref{del:virtual_machines} (Month 12): Creation, deployment,
      and distribution of preconfigured virtual machines (and/or
      Docker images) for \Pari, \Sage, ... as a cloud service, in
      particular within the StratusLab infrastructure. This includes
      build bots and test bots for continuous integration over a
      variety of operating systems.
      % Requires: licenses

    \item \ref{del:modularization} Modularization of the Sage distribution

      Separation of the different components of Sage (communication with
      third-party softwares, build system, Sage native code). This is a
      prerequisite for easier packaging and integration in standard Linux
      distributions and lmonade, native integration within the IPython
      notebook and other interfaces (larchenv, Spyder, ...) and
      collaboration with sister projects.

      % \TODO{lmonade has very similar objectives but uses the gentoo prefix whereas Linux distributions use very different packaging systems:
      % \begin{itemize}
      % \item gentoo prefix (gentoo)
      % \item pacman (arch),
      % \item yum (redhat),
      % \item apt (debian),
      % \item easy\_install
      % \item Python index packaging (pip)
      % \end{itemize}}

      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
      % Deliverables: Interfaces

    \item \ref{del:scscp_sage} Add support for the
      \href{http://www.symbolic-computing.org/}{SCSCP} interface protocol
      to all relevant components (e.g. Sage, ...).
      \TOWRITE{SL/AK}{Brief description of what SCSCP is, reference to
        previous grant, relevance to the goals of this grant; maybe this
        should go in the work package description}
        
        SCSCP (Symbolic Computation Software Composability Protocol) is a 
        remote procedure call protocol by which a computer algebra system (CAS) 
        may offer services to a variety of possible clients, including e.g. 
        another CAS running on the same computer system or remotely; 
        another instance of the same CAS (in a parallel computing context);
        a simplistic SCSCP client (e.g. C/C++/Python/etc. program) with a 
        minimal SCSCP support needed for a particular application; 
        a Web server which passes on the same services as Web services, etc.
        A distinctive feature of the protocol is that both instructions and data
        are represented in the OpenMath format (\url{http://www.openmath.org/};
        previously supported by the EU JEM Thematic Network; EU project 24969 ``ESPRIT''
        and other projects); moreover, OpenMath support is not limited by 
        existing official OpenMath content dictionaries - private encodings may 
        be easily embedded into SCSCP messages.
        
        SCSCP has been developed in the EU FP6 project 26133 ``SCIEnce -- Symbolic
        Computation Infrastructure for Europe'' (TODO: fix and insert URL) and by 
        now is supported by a number of computer algebra systems, including GAP, 
        Macaulay2, Maple, TRIP and others. To facilitate SCSCP implementations, 
        there are also APIs for Java, C and C++, and a simple Python SCSCP client
        (for a full overview, see SCIEnce website).
        
        TODO: more on the relevance to to the goals of this grant. This is useful 
        to exchange information between systems for problems that can not be solved
        within any single system; for storing and retrieving information (in databases)
        immediately into the CAS session; for organising distributed computations.


    \item Some IPython/Jupyter deliverables here.
      \TODO{review what it can already do in term of choice of
        computational resource and storage back-end.}
      \TODO{cross link to Task~\ref{task.ipython_kernels}}

    \item Contribution by Kaiserslautern: libSingular, pySingular?,
      GAP-Singular, Singular-Sage.

      Moving code from Sage into Singular when relevant

      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
      % Deliverables: HPC

    \item \ref{del:hpc_configure} (Month ...) Configure the components of
      Sage's distribution (e.g. Atlas, Linbox, GAP, Singular, ...) to be
      systematically HPC-enabled, and make sure that Sage's calls to such
      components indeed enable HPC.

      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
      % Deliverables: to be sorted ...

    \item Transparent integration of Ipython capabilities for cluster computing.
    \item Implementation of a transparent abstraction over mpi.
    \item Develop or integrate existing solutions for MapReduce operations
      over big data.

    \item FLINT development (key component for several systems)?

    \item Some demonstrators of cross-disciplinary/cross-software calculations

    \end{itemize}
  \end{WPDeliverables}
\begin{verbatim}
Raw material:

Component Architecture
----------------------

Recomputation connection belongs here?

Collaboration with unreliable (or restricted!) networking connections
(peer-to-peer, opportunistic syncing, 3rd world). This is technically
interesting, and gets in support for non-networked working. Not sure
if it belongs here or not.

- Security concerns

Goal: Fostering collaborations/integration between components in an open source ecosystem
=============================================================================

- How to make systems "cooperate" rather than "predate each other".
- E.g. reduce the version issues

- Foster collaboration with upstream libraries by sharing the
  development and maintenance of the interfaces, typically as
  standalone upstream Python bindings (e.g. py-Singular).

- How to make it easy to develop simultaneously two interdependent
  components (e.g. Sage+Singular)

- Foster communication

- Social aspect:
  Credit, Citations, Recognition, Funding

Documentation system
====================

In which package?

Improvements to Sphinx

Sage heavily customizes the Sphinx documentation system, hacking deep
in it in some cases, with quite some duplication in some cases.
Refactor the whole thing, generalizing and contributing back upstream
as much as possible (e.g. parallel compilation).
\end{verbatim}

\end{Workpackage}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../proposal"
%%% End: 
